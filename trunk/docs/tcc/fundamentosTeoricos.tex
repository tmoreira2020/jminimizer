\section{Fundamentação Teórica}
O produto final do desenvolvimento de uma aplicação Java é um ou mais arquivos class, também chamados de bytecode. Cada arquivo com a extensão class representa uma classe ou interface na aplicação (FALAR SOBRE INNNERCLASS ????). Esses arquivos class são o resultado da compilação dos arquivos de código fonte, e sua estrutura é praticamente um mapeamento um para um da linguagem Java.
É atravez desses arquivos class que analisei e fiz transformações na sua estrutura para reduzir o tamanho das aplicações Java. Uma breve explicação sobre a estrutura do bytecode se faz necessária, visto que eles são o objeto principal de estudo desse trabalho.

A estrutura do bytecode

Cada arquivo com a extensão class representa uma classe e ou uma interface na linguagem Java. Esses arquivos são constituídos de um array de bytes.
\begin{figure}[ht]
  \centering
  \includegraphics{imagens/classfile.jpg}
  \caption{formato de um arquivo .class\label{img:classfile}}
\end{figure}

A figura \ref{img:classfile} exemplifica de maneira simples a organização e o significado de cada byte ou conjunto de bytes. O significado das representações u1, u2 e u4 são: u representando um byte sem sinal e o decimal (1, 2 e 4) representado a quantidade de bytes. Então o valor magic é composto dos quatros primeiros bytes sem sinais do arquivo class. A seguir serão exemplificados cada uma das estruturas que compõem o bytecode.

\begin{enumerate}
\item magic: este numero é fixo para qualquer bytecode e tem o valor 0xCAFEBABE. O objetivo desse identificador é previnir as JVMs de carregar outras coisas que não sejam classes Java.
\item minor\_version: determina a menor versão que o bytecode suporta.
\item major\_version: determina a maior versão que o bytecode suporta.
\item constant\_pool\_count: determina a quantidade de constantes disponíveis no pool de constantes.
\item constant\_pool:  estrutura que contem todas as constantes utilizadas no bytecode. Estas constantes podem ser Strings, ints, longs, doubles, etc.
\item access\_flags:  este numero mascara os tipos de acesso que esta classes ou interface pode conter.
\item this\_class:  é o índice no pool  de constantes que contem o nome da classe.
\item super\_class: é o índice no pool de constantes que contem o nome da super classe.
\item interfaces\_count: determina a quantidade de interfaces que esta classe implementa diretamente, ou o numero de interfaces que esta interface estende.
\item interfaces:  um array contendo índices para os nomes das interfaces no pool  de constantes, que este bytecode implementa ou estende.
\item fields\_count: determina a quantidade de campos que esta classe ou interface possui.
\item fields: uma tabela que contem estruturas que representam um campo. A figura \ref{img:field} representa essa estrutura.

\begin{figure}[ht]
  \centering
  \includegraphics{imagens/field.jpg}
  \caption{estrutura de um campo \label{img:field}}
\end{figure}

\begin{enumerate}
\item access\_flags:  este numero mascara os tipos de acesso que este campo pode ter.
\item name\_index: índice no pool de constantes que contem o nome do campo.
\item descriptor\_index: índice no pool de constantes que contem a assinatura do campo.
\item attributes\_count: determina a quantidade de atributos que este campo possui.
\item attributes:  tabela que contem estruturas que representam os atributos deste campo.
\end{enumerate}
\item methods\_count: determina a quantidade de métodos que esta classe ou interface possui.
\item methods: tabela que contem estruturas que representam um método. A figura \ref{img:method} representa essa estrutura.

\begin{figure}[ht]
  \centering
  \includegraphics{imagens/method.jpg}
  \caption{estrutura de um método \label{img:method}}
\end{figure}

\begin{enumerate}
\item access\_flags:  este numero mascara os tipos de acesso que este método pode ter.
\item name\_index: índice no pool de constantes que contem o nome do método.
\item descriptor\_index: índice no pool de constantes que contem a assinatura do método.
\item attributes\_count: determina a quantidade de atributos que este método possui.
\item attributes:  tabela que contem estruturas que representam os atributos deste método.
\end{enumerate}
\item attributes\_count: determina a quantidade de atributos que esta classe ou interface possui.
\item attributes: tabela que contem estruturas que representam os atributos desta classe ou interface.
\end{enumerate}

Conhecendo a fundo o bytecode pude observar quais estruturas eu poderia fazer transformações ou até mesmo retira-las para diminuir o tamanho da aplicação. 
Na especificação da linguagem Java, está explicito que algumas das estruturas que encontramos no bytecode podem ser facilmente retiradas sem mudança no comportamento do software. A seção 4.7 de The JavaTM Virtual Machine Specification\cite[javaspec] exemplifica que alguns atributos tanto de classe, de métodos ou de campos, podem ser retirados sem nenhum problema. Estes atributos são SourceFile, LineNumberTable, LocalVariableTable e Deprecated. Os três primeiros dizem respeito somente a informações para depuração como o arquivo de código fonte do qual foi gerado a classe ou interface, tabela que contem os números das linhas mapeados com o das instruções e uma tabela que contem as variáveis locais dos métodos. O ultimo atributo sinaliza ao desenvolvedor que a classe, o método ou o campo que possui este atributo não deve ser utilizado pois ele entrou em desuso. Geralmente quando uma estrutura é marcada como Deprecated outra estrutura assume o papel da depreciada.
Vários compilador fornecem meios de na hora da geração do bytecode os atributos responsáveis pela depuração, serem excluídos do arquivo class. Esta é uma técnica de compactação de código Java simples e de pouco efeito colateral.

(PRECISO COLOCAR ESTATISTICAS SOBRE O USO E O NÃO USO DOS ATRIBUTOS DE DEPURAÇÃO)





Na maioria das vezes bibliotecas Java\cite{java} são disponibilizadas na forma de bytecode\cite{javaspec}, que são o resultado da compilação de um código fonte Java\cite{java}. Felizmente este tipo de representação é de alto nível e através desta representação é possível determinar hierarquias de classes, informações sobre tipos, aritmética flutuante, tabelas de variáveis locais, tabelas de numero de linhas, etc.
É baseado no bytecode Java que as transformações e compactações são realizadas, conseqüentemente não haverá problemas na manipulação das bibliotecas de terceiros, exceto se na licença da biblioteca conter termos que proíbam modificações na mesma. Se a biblioteca não for disponibilizada na forma de bytecode e sim como código fonte basta uma simples compilação para obtermos o bytecode desejado.
Existem alguns artifícios que podemos utilizar para diminuir ou compactar uma aplicação Java. Uma técnica muito simples e de pouco impacto é a remoção dos atributos de classe e de código dos métodos. Tabelas de variáveis locais, tabela de numero de linhas são dois exemplos de informações que estão disponíveis no bytecode Java e que podem ser descartas sem nenhum impacto em performance e comportamento da aplicação, já que estes dois atributos são utilizados para depuração.
