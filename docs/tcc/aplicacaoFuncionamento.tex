\chapter{Implementação do Compactador de Aplicações Java}
\section{Tipos de depêndencia}
Um programa Java pode ter dois tipos de dependência relacionados a bibliotecas e frameworks de terceiros. 
O primerio tipo de dependência está vinculado ao ambiente em que a aplicação depois de pronta será executado, e nesse artigo a identificamos como dependência do tipo \textit{runtime}. Suponhamos que estamos desenvolvendo um aplicativo para dispositivos móveis com suporte a Wireless Message API. Estes dispositivos possuem implementações das classes do pacote javax.wireless.messaging, sendo assim estas classes já estam disponiveis no ambiente de execução, no entanto para a compilação e para a analise estática do código elas são desconhecidas. Para a analise estática é preciso referencia-la, para que quando o JMinimizer começar a analiser a aplicação ele encontre todas as classes e interfaces que são referêncidas no código.
O outro tipo de dependência não está relacionado ao ambiente de execução, no entanto também deve estar presente neste. Esse tipo de dependêcia é criada pelo desenvolvedor quando para solucionar problemas de infra estrutura tipo parsers XML, logging, persistência, este utiliza bibliotecas e/ou frameworks para resolve-los. Como esta dependência não está disponível no ambiente de execução ela deve ser disponibilizada juntamente com a aplicação. Aqui neste artigo a identificamos como dependência do tipo \textit{program}.
Dito isto já entedemos que as dependências do tipo \textit{runtime} não precisam de nenhum tipo de tratamento, já que elas fazem parte do ambiente de execução. Já as dependências do tipo \textit{program} podem e devem ser modificadas para diminuir o tamanho final da aplicação, já que elas devem ser disponibilizadas juntamento com o software.
\section{Arquivo de configuração}
O arquivo de configuração do JMinimizer possue secções para a devida declaração de quais bibliotecas fazem parte da dependência do tipo \textit{runtime} e do tipo \textit{program}. 

Exemplo de dependêcia do tipo \textit{program}.
\lstset{
      language=XML,
      basicstyle=\scriptsize,
      %labelstyle=\scriptsize,
      %labelsep=1pt,
      %labelstep=1,
      tabsize=2,
      %firstlabel=1
  }

\lstinputlisting{fontes/programClasspath.xml}

Também no arquivo de configuração é necessário declarar o \textit{entry point} da aplicação. Geralmente o \textit{entry point} é o método main, startApp (para Midlets) ou start (para Applets). Além do método \textit{entry point} também é necessário declarar os métodos que serão chamados pelo ambiente de execução. Exemplo disto são os métodos startApp, pauseApp e destroyApp de um Midlet.


\lstinputlisting{fontes/entryPoint.xml}

Existe a possibilidade também de declarar pontos de parada para o JMinimizer, suponhamos que não há a necessidade de analisarmos classes do pacote \textbf{java.io}, basta para isso que declaremos no arquivo de configuração o seguinte trecho.

\lstinputlisting{fontes/notInspect.xml}

Feito isso todas as invocações de métodos de classes pertencentes ao pacote\textbf{java.io} não serão analisadas.
\section{Etapa de analise}
Tendo configurado as dependências os métodos que necessitam ser inspecionados e pontos de parada o JMinimizer irá método a método declarado inspecionar seu código a procura de novas invocações de métodos e acesso a atributos, tanto estáticos ou não. A medida que vai se achando novas invocações, essas chamadas de métodos e/ou atributos são adicionadas, se não pertencerem a um padrão de parada, à uma lista que contém uma única entrada para cada invocação de método ou acesso à atributo. No final do processo esta lista conterá todos os métodos e atributos que realmente compoêm o programa. Tanto métodos concretos, abstratos e nativos são adicionados a está lista, no entanto quando o JMinimizer encontra um método abstrato ou nativo ele não fará a inspeção do código, obviamente por este não o possuir.
Durante este processo é verificado para cada novo método encontrado se este representa \textit{\_java.lang.Class.forName(java.lang.String className)} se sim o método que contêm a invocação deste método é adicionado a uma lista que será processada posteriormente e uma mensagem de alerta é enviada ao usuário informando-o que tal método possui invocação de \textit{\_java.lang.Class.forName(java.lang.String className)}. Tudo isto é feito por que a linguagem Java suporta o carregamento dinâmico de classes. Dito isto, é necessário, para uma correta analise e tranformação do código, que o usuário declare no arquivo de configuração todas as classes que eventualmente poderão ser carregadas através da invocação do método que contêm a chamada à \textit{\_java.lang.Class.forName(java.lang.String className)}.
Finalizando o processo de analise, verificamos para todas as classes que foram encontradas, até então no processo, se estas classes possuem métodos que foram sobre escritos de suas classes e/ou interfaces pais. Se estas possuem métodos sobre escritos e que ainda não fazem parte da lista com todos os métodos da aplicação, estes serão adicionados a lista de métodos ainda não processados e o processo recomeçará. Ainda nessa etapa de analise é verificado para cada classe processada se está possue a invocação do método \textit{pacote.NomeDaClasse.$<$cinit$>$ ()V} que é o "construtor" padrão da classe. Esse método é invocado uma única vez após o carregamento da classe pela JVM. Ele é utilizado para setar valores a variáveis do tipo \textit{static final}.
\section{Transformação}
O resultado dessa etapa de analise é uma lista, sem entradas repetidas, com todos os métodos e campos que fazem realmente parte da aplicação. A partir dessa lista e de uma segunda lista com todas a classes que estão disponíveis como dependências do tipo \textit{program} será feita transformações visando a diminuição do código necessário para a execução da aplicação. 
A classe que efetua a transformação implementa o padrão \textit{Visitor}, assim sendo ela percorreá todas as classes que foram encontradas durante a etapa de analise e verificará para cada uma delas se esta possue métodos ou atributos que podem ser removidos. Se o método ou campo  pode ser removido, então ele é removido, caso contrario, e o método pertença a lista de métodos que invocam \textit{\_java.lang.Class.forName(java.lang.String className)}, é feita uma verificação no seu código para identificar se a chamada do método  \textit{\_java.lang.Class.forName(java.lang.String className)} foi implementada pelo desenvolvedor ou se foi um artifício usado pelo compilador para transformar a construção: \texttt{Class number= Number.class} numa chamada ao método  \textit{java.lang.Class.forName(java.lang.String className)}. Caso tenha sido o compilador que tenha produzido este código duas ações serão tomadas:
\begin{enumerate}
\item Será criado um método, na classe corrente em analise, que será responsável unica e exclusivamente a carregar classes oriundas da construção \texttt{Class number= Number.class}. Este método terá acesso publico e estático com a finalidade de todas as classes da aplicação terem acesso a ele. Esta ação é tomada uma única vez. Ela ocorre na primeira vez que for encontrado um código escrito pelo compilador com a finalidade de transformar em \textit{bytecode} a construção \texttt{Class number= Number.class}. Assim que a ação se conclui o nome da classe em que foi adicionado o método é armazenado para que o 2° passo seja executado sem problemas.
\item Será modificado o método que invoca  \textit{\_java.lang.Class.forName(java.lang.String className)} para que a partir de agora ele invoque o método que foi criado no passo anterior.
\end{enumerate}
O passo seguinte na transformação é retirar os atributos \textit{Deprecated, SourceFile, LineNumberTable, LocalVariableTable, Synthetic} das classes e ou interfaces e de seus membros (métodos e campos), caso no arquivo de configuração tenha sido declarado que deve ser feita uma compactação radical. A execução desse passo deve só ser feita quando o software foi testado exaustivamente, tanto na sua forma original como na forma compactada, pois os atributos que foram removidos são utilizados para debugging e portanto a aplicação deve estar estável para sofrer uma compactação radical.
\section{Limpeza do "pool" de constantes}
O passo seguinte é com certeza o mais importante e também o que levou mais tempo para ser implementado. Diz respeito a limpeza do "pool" de constantes, que é uma seção do bytecode que contém dados que são utilizados para referênciar classes, métodos e campos da própria classe e de outras classes. A limpeza se faz necessária pois quando são removidos métodos e campos de uma classe, o "pool" de constantes não é atualizado, ou seja, não são removidas as constantes que referenciavam o método e/ou campo, nem as referências das invocações de métodos que o método removido possuia. Visto que a atualização do "pool" não é feita, a quantidade de bytes não removidos pode ser muito maior que a quantidade removida, por este motivo que está etapa da compactação é de suma importância, pois remover um método pela metade não é nada eficiente.
No entanto, a operação de remover as constantes do "pool" é estremamente complicada, pois as contantes são armazenadas através de indices num array e são referênciadas na estrutura do bytecode através do seu indice nesse array, portanto quando uma constante é removida tem-se duas alternativas: ou, é mantido o tamanho do array e no lugar da constante removida é inserida uma outra, no entanto com um tamanho muito reduzido, ou, é redimensionado o array para que contenha somente espaço para as constantes que realmente são necessárias ao programa e se atualize os indices das constantes nas outras estruturas do bytecode.
A primeira versão funcional do JMinimizer contemplava a primeira alternativa na tentativa de limpar o "pool" de constantes e seu desenvolvimento foi simples, pois quando era encontrada uma constante que podia ser removida ela era somente substituida por uma muito menor.
Já a segunda versão do JMinimizer buscou redimensionar o "pool" de constantes e atualizar as estruturas que referênciavam as constantes que não eram excluídas. A tarefa de redimensionar o "pool" foi simples de executar, porém a atualização dos índices das constantes que não eram excluídas, foi o que tomou mais tempo e esforço para ser implementado, pois era necessário percorrer todas as estruturas do bytecode (métodos, campos, conjunto de instruções, manipuladores de exceções\dots) e atualizar o índice das constantes que essa estrutura referênciava.

\section{Peristência dos resultados}
Finalizando o processo temos a persistência da classe compactada e de todos os arquivos que estão disponíveis no classpath da dependência do tipo \textit{program} e que não são arquivos do tipo \textit{bytecode}, entre eles estão arquivos XML, figuras, etc. O programa final pode ser persistido num diretório ou em um arquivo do tipo jar\cite{jar}, essa configuração é feita no arquivo de configuração do projeto. Após este processo, é persistido o documento XML contendo todos os métodos e campos que foram retirados das classes, para cada classe que sofrer modificações é criado e persistido uma arquivo XML contendo estas entradas.
